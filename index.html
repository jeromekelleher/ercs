

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Extinction/recolonisation coalescent simulator &mdash; ercs 1.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ercs 1.0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">ercs 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="extinction-recolonisation-coalescent-simulator">
<h1><a class="toc-backref" href="#id14">Extinction/recolonisation coalescent simulator</a><a class="headerlink" href="#extinction-recolonisation-coalescent-simulator" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#extinction-recolonisation-coalescent-simulator" id="id14">Extinction/recolonisation coalescent simulator</a><ul>
<li><a class="reference internal" href="#introduction" id="id15">Introduction</a><ul>
<li><a class="reference internal" href="#basic-usage" id="id16">Basic usage</a></li>
<li><a class="reference internal" href="#samples" id="id17">Samples</a></li>
<li><a class="reference internal" href="#oriented-trees-and-forests" id="id18">Oriented trees and forests</a></li>
<li><a class="reference internal" href="#coalescence-times-and-mrcas" id="id19">Coalescence times and MRCAs</a></li>
<li><a class="reference internal" href="#multiple-loci" id="id20">Multiple loci</a></li>
</ul>
</li>
<li><a class="reference internal" href="#estimating-identity" id="id21">Estimating identity</a></li>
<li><a class="reference internal" href="#module-ercs" id="id22"><a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#ercs-simulator" id="id23"><a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a></a></li>
<li><a class="reference internal" href="#event-classes" id="id24">Event Classes</a></li>
<li><a class="reference internal" href="#utilities" id="id25">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-_ercs" id="id26"><a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a> &#8211; Module reference</a></li>
<li><a class="reference internal" href="#bibliography" id="id27">Bibliography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables" id="id28">Indices and tables</a></li>
</ul>
</div>
<p>The extinction/recolonisation model (or spatial Lambda-Fleming-Viot process)
is a recently-introduced model of populations evolving in continuous space.
In this model, individuals occupy a fixed location and all movement and
reproduction occur as a result of extinction/recolonisation events. Events
fall randomly in space, independent of the location of extant individuals.
In each event, some of the nearby individuals
die and are replaced by the descendants of a small
number of parents, drawn randomly from the population immediately
before the event.  See <a class="reference internal" href="#e08">[E08]</a>, <a class="reference internal" href="#bev10">[BEV10]</a>, <a class="reference internal" href="#bke10">[BKE10]</a>  and <a class="reference internal" href="#bev12">[BEV12]</a> for
discussions of the model, its background, and detailed mathematical
results.</p>
<p>This is the documentation for the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> Python module,
which provides a straightforward interface to coalescent simulations
for this model. The basic approach to simulating
the history of a sample and interpreting the results is explained through
a series of straightforward examples in the <a class="reference internal" href="#introduction">Introduction</a>  section.
We then work through a detailed example in the <a class="reference internal" href="#estimating-identity">Estimating identity</a>
section, which is followed by
detailed API documentation for the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module.</p>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id15">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Simulating the coalescent for the extinction/recolonisation model using
<a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> follows a basic pattern:</p>
<ol class="arabic simple">
<li>Allocate an instance of <a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a>;</li>
<li>Set the properties of the desired simulation by assigning values to the
attributes of this object;</li>
<li>Run the simulation for a given random seed using the <a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a>
method;</li>
<li>Analyse the resulting genealogies to obtain the information of interest.</li>
</ol>
<p>In the following examples we look at the parameters of the simulation, the
structure of the simulated genealogies (and how we can analyse them) and
how we can use these tools to estimate values of interest.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The examples in this section generally assume that Python 3
is being used, and may not work under Python 2. However,
both Python 2 and Python 3 are <strong>fully supported</strong> by <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a>.</p>
</div>
<div class="section" id="basic-usage">
<h3><a class="toc-backref" href="#id16">Basic usage</a><a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>To simulate the history of a set of individuals at a sample of
locations on a 2D torus, we first allocate an instance of the
<a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a> class. This class has a number of attributes
which can be set to describe the parameters of the desired simulation.
Most of these parameters have sensible defaults, but we must specify
at least three of these before we can run a simulation. Here is a
simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ercs</span>

<span class="k">def</span> <span class="nf">first_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span>  <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example we allocate a simulator on a torus of diameter 20,
and set up our sample and event classes. We then run the simulation
and return the resulting genealogy. The size of the torus is
rather arbitrary, as the real size of the habitat that
we imagine our population evolving on is determined by the scale
of events relative to the size of the torus. As a result, the size of the
torus can be any value you wish, once the spatial extent of events
is scaled appropriately.</p>
<p>The details of the model under which we imagine the population has evolved
are specified via one or more <em>event classes</em>.
We allocate a list of objects
that describe the type of events that we
are interested in, and assign these to the
<a class="reference internal" href="#ercs.Simulator.event_classes" title="ercs.Simulator.event_classes"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.event_classes</span></tt></a> attribute. In the example above,
we state that all events in the simulation are from the Disc model,
and they have radius <tt class="docutils literal"><span class="pre">r</span> <span class="pre">=</span>&nbsp; <span class="pre">1</span></tt> and impact <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">0.5</span></tt>.
There can be any number of event classes happening at different
rates: see <a class="reference internal" href="#event-classes">Event Classes</a> for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In these examples we&#8217;ll tend to
use rather large events, as it&#8217;s useful to have examples that
run quickly.</p>
</div>
</div>
<div class="section" id="samples">
<h3><a class="toc-backref" href="#id17">Samples</a><a class="headerlink" href="#samples" title="Permalink to this headline">¶</a></h3>
<p>The initial locations of the lineages whose ancestry we wish to simulate
are specified using the <a class="reference internal" href="#ercs.Simulator.sample" title="ercs.Simulator.sample"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.sample</span></tt></a> attribute, which is a list of
2-tuples describing locations on the torus.
There is a slightly awkward issue to deal with about how we use this list,
however.</p>
<p>In the simulation algorithm, locations in the sample are mapped to the
positive integers, <tt class="docutils literal"><span class="pre">1</span></tt> to <tt class="docutils literal"><span class="pre">n</span></tt>. These integers represent the nodes
that the lineage occupies in the tree describing the history of the
sample, and this relationship is most simply described using a list.
The awkwardness arises in the discrepancy between this convention of
counting from <tt class="docutils literal"><span class="pre">1</span></tt> and Python&#8217;s convention of making the index of
the first element of a list <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>To avoid inconsistencies between the input and output of the simulations,
we therefore adopt the convention that the zero&#8217;th element of the sample
must be <tt class="docutils literal"><span class="pre">None</span></tt>. So, in the sample above we simulate the history of
three locations <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt>, <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">5)</span></tt> and <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">10)</span></tt>, which are
mapped to nodes <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt> respectively. Writing the
mapping out explicitly we get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)}</span>
<span class="go">{1: (0, 0), 2: (0, 5), 3: (0, 10)}</span>
</pre></div>
</div>
</div>
<div class="section" id="oriented-trees-and-forests">
<h3><a class="toc-backref" href="#id18">Oriented trees and forests</a><a class="headerlink" href="#oriented-trees-and-forests" title="Permalink to this headline">¶</a></h3>
<p>After we have completed setting up the parameters of the simulation
we can then run it by calling
<a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a> for a given random seed.
Running the example above, we get</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">first_example</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([[-1, 4, 4, 5, 5, 0]], [[-1, 0.0, 0.0, 0.0, 30441.574004183603, 46750.11224375103]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is nothing special about the seed 3 here&#8212;it is just a value which
produced a neat example to discuss.</p>
</div>
<p>This output completely describes the ancestry of the sample, although it&#8217;s not immediately
obvious how. In <tt class="docutils literal"><span class="pre">ercs</span></tt> we use <em>oriented trees</em> to represent the genealogy of a sample.
In an oriented tree, we are only interested in parent-child relationships
and don&#8217;t care about the order of children at a node.
If we map each node in the tree to a unique
positive integer and adopt the convention that any node whose parent is the
special &#8220;null node&#8221; <tt class="docutils literal"><span class="pre">0</span></tt> is a root,
we can then represent an oriented tree very simply as a list of integers.
So, an oriented tree <tt class="docutils literal"><span class="pre">pi</span></tt> is  a list in which
the parent of node <tt class="docutils literal"><span class="pre">j</span></tt> is <tt class="docutils literal"><span class="pre">pi[j]</span></tt>, the grandparent of <tt class="docutils literal"><span class="pre">j</span></tt> is <tt class="docutils literal"><span class="pre">pi[pi[j]]</span></tt>
and so on.</p>
<p>The <a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a> method returns a tuple, <tt class="docutils literal"><span class="pre">(pi,</span> <span class="pre">tau)</span></tt>;
<tt class="docutils literal"><span class="pre">pi</span></tt> is a list of oriented forests (one for each locus) and <tt class="docutils literal"><span class="pre">tau</span></tt> is a list of
node times (one for each locus). In the example, we are dealing with a single locus,
so <tt class="docutils literal"><span class="pre">pi</span></tt> is a list consisting of one list, <tt class="docutils literal"><span class="pre">[-1,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">5,</span> <span class="pre">0]</span></tt>.
This list encodes the following tree, in which
the leaf nodes <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt> corresponds to the locations in our sample:</p>
<img alt="An oriented tree" class="align-center" src="_images/oriented-tree.png" style="width: 15cm;" />
<p>Mapping all nodes in the oriented tree to their parents explicitly, we get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">first_example</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]))}</span>
<span class="go">{1: 4, 2: 4, 3: 5, 4: 5, 5: 0}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The zero&#8217;th element of an oriented forest and its associated node
time list is not used and is set to -1 by convention,
following Knuth (Algorithm O, section 7.2.1.6) <a class="reference internal" href="#k11">[K11]</a>.</p>
</div>
<p>The times labelled on the tree are derived from the node times list for this
locus, <tt class="docutils literal"><span class="pre">tau[0]</span></tt>. The node times list associated with an oriented tree
records the time that the associated lineage entered the sample, looking
backwards in time.</p>
<p>Oriented <em>forests</em> occur when there is more than one root in a list <tt class="docutils literal"><span class="pre">pi</span></tt>, and
so we have a set of disconnected trees. This can happen when we specify
the <a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a> attribute, potentially stopping the simulation before
the sample has completely coalesced. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">oriented_forest_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="mf">1e5</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Here we allocate a Simulator on a torus of diameter 20 as before and
use the usual event class. This time we allocate a sample of size 10,
arranged regularly along a line, and stipulate that the simulation should
continue for no more then 10<sup>5</sup> time units. As we&#8217;re only
interested in the structure of the genealogy this time, we just
return the oriented forest at the first locus. Running this, we get</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">oriented_forest_example</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[-1, 0, 15, 0, 12, 12, 13, 11, 13, 11, 16, 16, 14, 14, 15, 0, 0]</span>
</pre></div>
</div>
<p>In this forest there are <em>four</em> roots: 1, 3, 15 and 16.</p>
<img alt="An oriented forest" class="align-center" src="_images/oriented-forest.png" style="width: 15cm;" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This forest is <strong>not</strong> a correct representation of the
node times; in any simulation, node <tt class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></tt> cannot be more recent
than node <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
</div>
</div>
<div class="section" id="coalescence-times-and-mrcas">
<h3><a class="toc-backref" href="#id19">Coalescence times and MRCAs</a><a class="headerlink" href="#coalescence-times-and-mrcas" title="Permalink to this headline">¶</a></h3>
<p>In coalescent simulations we are usually interested in the
coalescence time of two or more lineages in our sample,
which is the time back to their most recent
recent common ancestor (MRCA).
This is straightforward to do in <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> using the
<a class="reference internal" href="#ercs.MRCACalculator" title="ercs.MRCACalculator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.MRCACalculator</span></tt></a> class to find the most recent
common ancestor of two nodes and then looking up the node
times list to find the time that this node entered the sample.</p>
<p>In the following example, we print out the pairwise coalescence
time for a sample of size 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mrca_example</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">mc</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">MRCACalculator</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;pi  = &quot;</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;tau = &quot;</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mrca</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mrca</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mrca({0}, {1}) = {2} @ {3:.2f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mrca</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mrca_example</span><span class="p">(</span><span class="mi">10292</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">pi  =  [[-1, 5, 5, 6, 6, 7, 7, 0]]</span>
<span class="go">tau =  [[-1, 0.0, 0.0, 0.0, 0.0, 1495.7013764597423, 51935.87882804881, 231859.81270041558]]</span>
<span class="go">        mrca(1, 2) = 5 @ 1495.70</span>
<span class="go">        mrca(1, 3) = 7 @ 231859.81</span>
<span class="go">        mrca(1, 4) = 7 @ 231859.81</span>
<span class="go">        mrca(2, 3) = 7 @ 231859.81</span>
<span class="go">        mrca(2, 4) = 7 @ 231859.81</span>
<span class="go">        mrca(3, 4) = 6 @ 51935.88</span>
</pre></div>
</div>
<p>Here we can see, for example, that the MRCA of nodes <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt> is <tt class="docutils literal"><span class="pre">7</span></tt>
(since the parent of <tt class="docutils literal"><span class="pre">1</span></tt> is <tt class="docutils literal"><span class="pre">5</span></tt>, the parent of <tt class="docutils literal"><span class="pre">3</span></tt> is <tt class="docutils literal"><span class="pre">6</span></tt>
and <tt class="docutils literal"><span class="pre">5</span></tt> and <tt class="docutils literal"><span class="pre">6</span></tt> are both children of <tt class="docutils literal"><span class="pre">7</span></tt>).
Then, reading the time of node <tt class="docutils literal"><span class="pre">7</span></tt> from <tt class="docutils literal"><span class="pre">tau</span></tt> we see that their coalescence
time is 231859.81.</p>
</div>
<div class="section" id="multiple-loci">
<h3><a class="toc-backref" href="#id20">Multiple loci</a><a class="headerlink" href="#multiple-loci" title="Permalink to this headline">¶</a></h3>
<p>In the extinction/recolonisation model
recombination rates are specified by
describing the probability that two adjacent loci <tt class="docutils literal"><span class="pre">l</span></tt>
and <tt class="docutils literal"><span class="pre">l</span> <span class="pre">+</span> <span class="pre">1</span></tt> descend from different parents at an event. Therefore, in
a system of <tt class="docutils literal"><span class="pre">m</span></tt> loci, we need a list of <tt class="docutils literal"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">1</span></tt> recombination
probabilities to describe the system in a general way. The
probabilities of recombination between different pairs of
adjacent loci are independent, and so there is no interference in the system.</p>
<p>The <a class="reference internal" href="#ercs.Simulator.recombination_probabilities" title="ercs.Simulator.recombination_probabilities"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.recombination_probabilities</span></tt></a> attribute is used
to describe both the number of loci and the recombination rates between them.
By default, this attribute is set to the empty list, giving a single
locus system. In the following example we set up a three locus system
in which we calculate the coalescence time at each locus:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">multi_locus_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">recombination_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">tau</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">tau</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">multi_locus_example</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="go">(256162.39313980262, 190032.351005425, 190032.351005425)</span>
</pre></div>
</div>
<p>(There are only two lineages in our sample so
the MRCA of nodes <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">2</span></tt> must be be <tt class="docutils literal"><span class="pre">3</span></tt>.)
This shows us that there was an effective recombination
between the first and second locus at come point in the history
of the sample, since the coalescence time at the first locus is not
the same as the other two loci.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Loci are zero-indexed in the usual Python way, unlike individuals
in the sample.</p>
</div>
<p>The example above shows how we can simulate two loci, and can be
easily generalised to larger numbers of loci. Since the number
of lineages can become very large when we deal with large numbers of loci,
however, it may be necessary to become familiar with some more advanced properties
of the simulation implementation.</p>
<p>The first issue is to decide how much memory you are willing to dedicate
to the task of tracking lineages; this is done by specifying the maximum
number of lineages in the sample using the
<a class="reference internal" href="#ercs.Simulator.max_lineages" title="ercs.Simulator.max_lineages"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_lineages</span></tt></a> attribute.
When the number of lineages in the sample
exceeds this limit, the simulation fails with an exception, as
illustrated in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">out_of_memory_example</span><span class="p">():</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">max_lineages</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">recombination_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">499</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out_of_memory_example</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">7</span>, in <span class="n">out_of_memory_example</span>
  File <span class="nb">&quot;ercs.py&quot;</span>, line <span class="m">118</span>, in <span class="n">run</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gr">_ercs.LibraryError</span>: <span class="n">Out of lineage memory</span>
</pre></div>
</div>
<p>The example fails because we try to simulate the
ancestry of two 500 locus individuals with a limit of only 10 extant lineages.
If we wish to simulate the entire history of the sample, we must increase
the number maximum number of lineages. On the other hand, if we are only
interested in the recent history of the sample, we can stop the simulation
before the sample gets too large using the <a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a>
attribute.</p>
<p>Lineages are indexed using a kdtree to allow us to find
the lineages that may potentially be hit by an event
efficiently. The
<a class="reference internal" href="#ercs.Simulator.kdtree_bucket_size" title="ercs.Simulator.kdtree_bucket_size"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.kdtree_bucket_size</span></tt></a> and
<a class="reference internal" href="#ercs.Simulator.max_kdtree_insertions" title="ercs.Simulator.max_kdtree_insertions"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_kdtree_insertions</span></tt></a>
attributes provide a means of tuning this data structure for
performance when large numbers of lineages are involved.</p>
</div>
</div>
<div class="section" id="estimating-identity">
<h2><a class="toc-backref" href="#id21">Estimating identity</a><a class="headerlink" href="#estimating-identity" title="Permalink to this headline">¶</a></h2>
<p>The examples up to this point have been intended to illustrate the core
concepts of using <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a>, and have not done anything particularly
useful.  In this section we work through a complete example of how the module can
be used to estimate the probability of identity in state.
The example is necessarily more complex that the toy examples above, but
should provide a useful template for further simulations.
To keep the code as concise as possible we use the
popular <a class="reference external" href="http://numpy.scipy.org/">NumPy</a> and
<a class="reference external" href="http://matplotlib.org/">matplotlib</a> third party packages. These packages
are included in most operating system package managers, or can be installed
from the <a class="reference external" href="http://pypi.python.org/pypi">Python Package Index</a>.</p>
<p>To begin with, we import some modules we&#8217;ll need later
and define a class extending <a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ercs</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">ticker</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>

<span class="k">class</span> <span class="nc">SingleLocusIdentitySimulator</span><span class="p">(</span><span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that calculates identity in state for genes separated by a range</span>
<span class="sd">    of distances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">mutation_rate</span><span class="p">,</span> <span class="n">accuracy_goal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up the simulation so that we calculate identity at the specified</span>
<span class="sd">        number of points, the maximum distance between points is</span>
<span class="sd">        max_distance and mutation happens at the specified rate. Also</span>
<span class="sd">        set the max_time attribute to reflect the specified accuracy_goal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">=</span> <span class="n">mutation_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">accuracy_goal</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mutation_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the probability of identity at all distance classes</span>
<span class="sd">        in this replicate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">MRCACalculator</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">mrca</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mrca</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mrca</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">F</span>
</pre></div>
</div>
<p>Under the infinite alleles model, the probability of identity in state for two genes
with coalescence time <tt class="docutils literal"><span class="pre">t</span></tt> is given by <tt class="docutils literal"><span class="pre">exp(-2</span> <span class="pre">*</span> <span class="pre">mu</span> <span class="pre">*</span> <span class="pre">t)</span></tt>, assuming mutations
arise at rate <tt class="docutils literal"><span class="pre">mu</span></tt>. Mutations occur independently along the branches of the
genealogy, and the number of mutations on each branch follows a Poisson distribution.
Therefore, the probability that zero mutational events happen along one branch
is <tt class="docutils literal"><span class="pre">exp(-mu</span> <span class="pre">*</span> <span class="pre">t)</span></tt> and the probability that zero mutations occur on both
branches is <tt class="docutils literal"><span class="pre">exp(-2</span> <span class="pre">*</span> <span class="pre">mu</span> <span class="pre">*</span> <span class="pre">t)</span></tt>.</p>
<p>In these simulations we wish to estimate the <em>mean</em> of the distribution
of probability of identity in state for a known
mutation rate. Under these conditions we can make an observation
that dramatically reduces the
amount of time we need to spend simulating the model.
In the extinction/recolonisation
model there is a strong separation of timescales effect, in which nearby
genes either coalesce in the relatively recent past or they spent a very
long time wandering around the torus. So long, in fact, that their
contribution to the mean of the distribution of
probability of identity in state is negligible.</p>
<p>We can make this a bit more concrete if we define a value <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt>, below which
we consider probabilities of identity to be negligible. Let&#8217;s say for example
that this is 10<sup>-10</sup>, and our mutation rate <tt class="docutils literal"><span class="pre">mu</span></tt> is
10<sup>-6</sup>. We can then solve for <tt class="docutils literal"><span class="pre">t</span></tt> to find the time that corresponds
to these values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">max_t</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_t</span>
<span class="go">11512925.46497023</span>
</pre></div>
</div>
<p>We then use the <a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a> attribute to ensure
that the simulation stops when <tt class="docutils literal"><span class="pre">max_t</span></tt> is reached. If lineages
have coalesced, then we know that their probability of identity
in state is no less than 10<sup>-10</sup>, and if lineages
have not coalesced, then their identity is
less than 10<sup>-10</sup> which we have decided
should be treated as zero.</p>
<p>The <tt class="docutils literal"><span class="pre">setup</span></tt> method implements these ideas to set the
<a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a> attribute for a given mutation rate
and accuracy goal, and also sets up the sample so
that we can calculate the probability of identity in state at a sequence
of evenly spaced separation distances. The <tt class="docutils literal"><span class="pre">get_identity</span></tt> method
then runs a replicate of the simulation and calculates the probability
of identity at each distance. If a pair of lineages has no
MRCA then we know that they have not coalesced, and so we set
their probability of identity to zero.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt> in no way implies that the digits greater
than <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt> in  a probability of identity are correct.
We can guarantee only
the following: if <tt class="docutils literal"><span class="pre">u</span></tt> is the probability of identity in state calculated
using a given value of <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt> and <tt class="docutils literal"><span class="pre">v</span></tt> is the value calculated
by letting the simulation continue until coalescence <em>for the same
random seed</em>, then <tt class="docutils literal"><span class="pre">v</span> <span class="pre">-</span> <span class="pre">u</span> <span class="pre">&lt;=</span> <span class="pre">accuracy_goal</span></tt>. This property is sufficient
for estimating the <em>mean</em> of a distribution to approximately <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt>
if the true mean is much greater than <tt class="docutils literal"><span class="pre">accuracy_goal</span></tt>,
but is not sufficient to estimate statistics in general.
<strong>Use with caution!</strong></p>
</div>
<p>The variance in coalescence times in the extinction/recolonisation
model is very large, and so we need a large number of replicates to estimate
the mean identity with reasonable accuracy.
These replicates are independent, however, so
we can run them in parallel quite easily.
We use the following pair of functions to generate
a set of random seeds, distribute these jobs to pool of worker
processes provided by the <a class="reference external" href="http://docs.python.org/3.2/library/multiprocessing.html#multiprocessing" title="(in Python v3.2)"><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></tt></a> module and save the
results to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">subprocess_worker</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">sim</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">return</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_identity</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run_replicates</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">,</span> <span class="n">worker_pool</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sim</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">)]</span>
    <span class="n">replicates</span> <span class="o">=</span> <span class="n">worker_pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">subprocess_worker</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">mean_identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">replicates</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mean_identity</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The particular structure of how these two functions are called is dictated by
the technical details of how multiprocessing works. Specifically,
the argument to <tt class="xref py py-meth docutils literal"><span class="pre">multiprocessing.Pool.map()</span></tt> must be picklable so we cannot
call <tt class="docutils literal"><span class="pre">sim.get_identity(seed)</span></tt> directly.</p>
</div>
<p>We then have all the tools we need to define our top-level simulation function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">run_simulations</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">SingleLocusIdentitySimulator</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">small_events</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">large_events</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">workers</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">small_events</span><span class="p">]</span>
    <span class="n">run_replicates</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="s">&quot;small.dat&quot;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">,</span> <span class="n">workers</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">large_events</span><span class="p">]</span>
    <span class="n">run_replicates</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="s">&quot;large.dat&quot;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">,</span> <span class="n">workers</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">small_events</span><span class="p">,</span> <span class="n">large_events</span><span class="p">]</span>
    <span class="n">run_replicates</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="s">&quot;mixed.dat&quot;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">,</span> <span class="n">workers</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;simulator.dat&quot;</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>We start by allocating a simulator on a torus of diameter <tt class="docutils literal"><span class="pre">100</span></tt>, and then
set up our sample so that we have fifty equally spaced distances from <tt class="docutils literal"><span class="pre">0</span></tt>
to <tt class="docutils literal"><span class="pre">20</span></tt>. We also define our mutation rate of 10<sup>-6</sup>, and, since
we&#8217;re just generating an example for a web page and already know
the rough magnitude of the values we wish to plot, set our accuracy goal
to 10<sup>-3</sup>.
A convenient way to plot these results in Python is to
use <a class="reference external" href="http://matplotlib.org/">matplotlib</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">generate_plot</span><span class="p">():</span>
    <span class="n">small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s">&quot;small.dat&quot;</span><span class="p">)</span>
    <span class="n">mixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s">&quot;mixed.dat&quot;</span><span class="p">)</span>
    <span class="n">large</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s">&quot;large.dat&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;simulator.dat&quot;</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">distances</span><span class="p">,</span> <span class="n">small</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;small&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">distances</span><span class="p">,</span> <span class="n">mixed</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;mixed&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">distances</span><span class="p">,</span> <span class="n">large</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;large&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s">&quot;log&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">large</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">small</span><span class="p">))</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_minor_formatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">ScalarFormatter</span><span class="p">())</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&quot;F(x)&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&quot;upper right&quot;</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&quot;identity.png&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">72</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">run_simulations</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
    <span class="n">generate_plot</span><span class="p">()</span>
</pre></div>
</div>
<p>Running the complete code, which will take a few hours, gives us
the following plot:</p>
<img alt="Probability of identity in state." class="align-center" src="_images/identity.png" style="width: 15cm;" />
<p>There are much better ways to estimate the mean of the distribution of
the probability of identity in
state, of course. This section is intended to provide an example
of how <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> can be used to estimate statistics for which analytical
or numerical methods are not available.</p>
</div>
<div class="section" id="module-ercs">
<span id="ercs-module-reference"></span><h2><a class="toc-backref" href="#id22"><a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> &#8211; Module reference</a><a class="headerlink" href="#module-ercs" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">ercs</span></tt> module provides a convenient interface to coalescent simulations
for the extinction/recolonisation model, and some utilities to process
the resulting genealogies.</p>
<div class="section" id="ercs-simulator">
<h3><a class="toc-backref" href="#id23"><a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a></a><a class="headerlink" href="#ercs-simulator" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="ercs.Simulator">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">Simulator</tt><big>(</big><em>torus_diameter</em><big>)</big><a class="headerlink" href="#ercs.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a coalescent simulator for the extinction/recolonisation
model on a torus of the specified diameter.</p>
<dl class="attribute">
<dt id="ercs.Simulator.sample">
<tt class="descname">sample</tt><a class="headerlink" href="#ercs.Simulator.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>The location of lineages at the beginning of the simulation. This
must be a list of 2-tuples describing locations
within the 2D space defined by the torus. The zero&#8217;th element
of this list <strong>must be</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p><strong>Default value:</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.event_classes">
<tt class="descname">event_classes</tt><a class="headerlink" href="#ercs.Simulator.event_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The event classes to simulate. This must be a list of
<a class="reference internal" href="#ercs.EventClass" title="ercs.EventClass"><tt class="xref py py-class docutils literal"><span class="pre">ercs.EventClass</span></tt></a>
instances. There must be at least one event class specified.</p>
<p><strong>Default value:</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.torus_diameter">
<tt class="descname">torus_diameter</tt><a class="headerlink" href="#ercs.Simulator.torus_diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>The diameter of the torus we are simulating on. This defines the
size of the space that lineages can move around in.</p>
<p><strong>Default value:</strong> Specified at instantiation time.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.num_parents">
<tt class="descname">num_parents</tt><a class="headerlink" href="#ercs.Simulator.num_parents" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parents in each event. For a single locus simulation
there must be at least one parent and for multi-locus simulations
at least two.</p>
<p><strong>Default value:</strong> 1 if the simulation is single locus, otherwise 2.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.recombination_probabilities">
<tt class="descname">recombination_probabilities</tt><a class="headerlink" href="#ercs.Simulator.recombination_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of inter-locus recombination probabilities; the length of
this list also determines the number of loci for each individual.
At an event, the probability of locus <tt class="docutils literal"><span class="pre">j</span></tt> and <tt class="docutils literal"><span class="pre">j</span> <span class="pre">+</span> <span class="pre">1</span></tt> descending
from different parents is <tt class="docutils literal"><span class="pre">recombination_probabilities[j]</span></tt>.
The number of loci in the simulation is therefore
<tt class="docutils literal"><span class="pre">len(recombination_probabilities)</span> <span class="pre">+</span> <span class="pre">1</span></tt>.</p>
<p><strong>Default value:</strong> The empty list [] (so, we have a single locus
simulation by default).</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_time">
<tt class="descname">max_time</tt><a class="headerlink" href="#ercs.Simulator.max_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum amount of time (in simulation units) that we simulate. If
this is set to <cite>0.0</cite> the simulation continues until all loci have
coalesced.</p>
<p><strong>Default value:</strong> 0.0</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_lineages">
<tt class="descname">max_lineages</tt><a class="headerlink" href="#ercs.Simulator.max_lineages" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of extant lineages in the simulation.
If the number of lineages we are tracking exceeds this limit,
the simulation aborts and raises an <tt class="xref py py-exc docutils literal"><span class="pre">_ercs.LibraryError</span></tt>.</p>
<p><strong>Default value:</strong> 1000</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.kdtree_bucket_size">
<tt class="descname">kdtree_bucket_size</tt><a class="headerlink" href="#ercs.Simulator.kdtree_bucket_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of locations in a leaf node of the kdtree, which  must be a power of
two. The <tt class="docutils literal"><span class="pre">kdtree_bucket_size</span></tt>
is an advanced parameter that may be useful in tuning performance when very
large numbers of lineages are involved. Larger values will result in less
time and memory spent indexing the lineages, but more lineages will need to
be tested to see if they are within the critical radius of the event. <strong>Note:</strong>
changing this parameter affects the outcome of simulations! That is, if we
change the value of the bucket size, we cannot expect the outcome of two
simulations with the same random seed to be the same. The reason for this
is that, although we are guaranteed to end up with the same set of lineages
in an event in any case, the <em>order</em> in which they die may be different,
pushing the simulation onto a different stochastic trajectory.</p>
<p><strong>Default value:</strong> 1</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_kdtree_insertions">
<tt class="descname">max_kdtree_insertions</tt><a class="headerlink" href="#ercs.Simulator.max_kdtree_insertions" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of insertions into the kdtree before a rebuild, or
0 if the tree is not to be rebuilt. This parameter is useful for tuning the
performance of the simulation when
we have large numbers of loci, particularly if we begin with a relatively
small sample. In this case, as the number of lineages increases over time
and they spread outwards to cover more and more of the torus, we need to
rebuild the index periodically. If we begin with a large sample uniformly
distributed around the space then this can safely be set to 0.</p>
<p><strong>Default value:</strong> 0</p>
</dd></dl>

<dl class="method">
<dt id="ercs.Simulator.run">
<tt class="descname">run</tt><big>(</big><em>random_seed</em><big>)</big><a class="headerlink" href="#ercs.Simulator.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the coalescent simulation for the specified random seed, 
and returns the simulated history, (pi, tau). The history consists
of a list of oriented forests (one for each locus) and their
corresponding node times (one for each locus).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random_seed</strong> (<em>integer.</em>) &#8211; the value to initialise the random number
generator</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the simulated history of the sample, (pi, tau)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a tuple <tt class="docutils literal"><span class="pre">(pi,</span> <span class="pre">tau)</span></tt>; <tt class="docutils literal"><span class="pre">pi</span></tt> is a list of lists of integers, 
and <tt class="docutils literal"><span class="pre">tau</span></tt> is a list of lists of doubles</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">_ercs.InputError</span></tt> when the input is not correctly formed</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">_ercs.LibraryError</span></tt> when the C library encounters an 
error</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="event-classes">
<h3><a class="toc-backref" href="#id24">Event Classes</a><a class="headerlink" href="#event-classes" title="Permalink to this headline">¶</a></h3>
<p>The classes of event in a given simulation are specified by
providing a list of Event Class instances
in the <a class="reference internal" href="#ercs.Simulator.event_classes" title="ercs.Simulator.event_classes"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.event_classes</span></tt></a> attribute.
Two classes of event are currently supported:
the Disc model and the Gaussian model. See <a class="reference internal" href="#e08">[E08]</a>, <a class="reference internal" href="#bev10">[BEV10]</a>, <a class="reference internal" href="#bev12">[BEV12]</a>
and several other articles for details of the Disc model, and see
<a class="reference internal" href="#bke10">[BKE10]</a> and <a class="reference internal" href="#bev12">[BEV12]</a> for details of the Gaussian model.</p>
<dl class="class">
<dt id="ercs.EventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">EventClass</tt><big>(</big><em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.EventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing the an Event Class in the extinction/recolonisation model. 
Events of a particular class occur at a specific rate and have fixed parameters,
the details of which depend on the specific model.</p>
</dd></dl>

<dl class="class">
<dt id="ercs.DiscEventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">DiscEventClass</tt><big>(</big><em>r</em>, <em>u</em>, <em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.DiscEventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing events from the Disc model, in which all individuals within
distance <em>r</em> of the centre of an event have probability <em>u</em> of dying in the 
event and parents are thrown down uniformly within this disc.</p>
</dd></dl>

<dl class="class">
<dt id="ercs.GaussianEventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">GaussianEventClass</tt><big>(</big><em>theta</em>, <em>alpha</em>, <em>u0</em>, <em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.GaussianEventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing events from the Gaussian model, in which an individual at  
distance <em>d</em> of the centre of the event have probability 
<img class="math" src="_images/math/cce1afa36a021361aede55e0453e74264871da87.png" alt="u_0\exp(-d^2/(2\theta^2))"/> of dying in the event. Parents are thrown down 
around the centre of the event according to a 2D Gaussian with variance 
<img class="math" src="_images/math/ce130d89991915e0f88bd671d4cb36bcadaa7a80.png" alt="\theta^2\alpha^2"/>.</p>
</dd></dl>

</div>
<div class="section" id="utilities">
<h3><a class="toc-backref" href="#id25">Utilities</a><a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="ercs.torus_distance">
<tt class="descclassname">ercs.</tt><tt class="descname">torus_distance</tt><big>(</big><em>x</em>, <em>y</em>, <em>L</em><big>)</big><a class="headerlink" href="#ercs.torus_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Euclidean distance between two points x and y on a 2D
square torus with diameter L.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>two-tuple of numeric values</em>) &#8211; first point</li>
<li><strong>y</strong> (<em>two-tuple of numeric values</em>) &#8211; second point</li>
<li><strong>L</strong> &#8211; torus diameter</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">floating point value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="ercs.MRCACalculator">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">MRCACalculator</tt><big>(</big><em>oriented_forest</em><big>)</big><a class="headerlink" href="#ercs.MRCACalculator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to that allows us to compute the nearest common ancestor of arbitrary
nodes in an oriented forest.</p>
<p>This is an implementation of Schieber and Vishkin&#8217;s nearest common ancestor 
algorithm from TAOCP volume 4A, pg.164-167 <a class="reference internal" href="#k11">[K11]</a>. Preprocesses the 
input tree into a sideways heap in O(n) time and processes queries for the 
nearest common ancestor between an arbitary pair of nodes in O(1) time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>oriented_forest</strong> (<em>list of integers</em>) &#8211; the input oriented forest</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ercs.MRCACalculator.get_mrca">
<tt class="descname">get_mrca</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#ercs.MRCACalculator.get_mrca" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the most recent common ancestor of the nodes x and y, 
or 0 if the nodes belong to different trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>positive integer</em>) &#8211; the first node</li>
<li><strong>y</strong> (<em>positive integer</em>) &#8211; the second node</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the MRCA of nodes x and y</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><p class="first last">non-negative integer</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-_ercs">
<span id="id13"></span><h2><a class="toc-backref" href="#id26"><a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a> &#8211; Module reference</a><a class="headerlink" href="#module-_ercs" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module delegates the majority of its work to the low-level <a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a>
extension module, which is written in C. It is not recommended to use this
module directly&#8212;the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module provides all of the functionality with a
much more straightforward interface. In the interest of completeness,
however, the low-level module is documented here.</p>
<dl class="function">
<dt id="_ercs.simulate">
<tt class="descclassname">_ercs.</tt><tt class="descname">simulate</tt><big>(</big><big>)</big><a class="headerlink" href="#_ercs.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates an ercs object from the C library, calls the simulate function and returns the resulting genealogy. All arguments must be specified and be in the correct order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>random_seed</strong> (<em>long integer</em>) &#8211; The seed used for the GSL random generator</li>
<li><strong>torus_diameter</strong> (<em>double</em>) &#8211; The diameter of the torus</li>
<li><strong>num_parents</strong> (<em>unsigned integer</em>) &#8211; The number of parents in each event</li>
<li><strong>sample</strong> (<em>list of numeric (x, y) tuples</em>) &#8211; The (zero indexed) sample of 2D locations</li>
<li><strong>event_classes</strong> (<em>list of dictionaries</em>) &#8211; The list of event classes and their rates</li>
<li><strong>recombination_probabilities</strong> (<em>list of doubles</em>) &#8211; probability of recombination between adjacent loci</li>
<li><strong>kdtree_bucket_size</strong> (<em>unsigned integer</em>) &#8211; The number of points in a kdtree bucket</li>
<li><strong>max_kdtree_insertions</strong> (<em>unsigned integer</em>) &#8211; The maximum number of insertions before  the kdtree is rebuilt; if 0, the kdtree is never rebuilt</li>
<li><strong>max_lineages</strong> (<em>unsigned integer</em>) &#8211; The maximum number of extant lineages</li>
<li><strong>max_time</strong> (<em>double</em>) &#8211; the maximum time we simulate back into the past; if 0.0, simulate until coalescence</li>
<li><strong>ancestry_algorithm</strong> (<em>unsigned int</em>) &#8211; currently unused</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the simulated history of the sample, (pi, tau).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">a tuple (pi, tau); pi is a list of lists of integers, and         tau is a list of lists of doubles</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first">InputError when the input is not correctly formed.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">LibraryError when the C library encounters an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>In the <tt class="docutils literal"><span class="pre">_ercs</span></tt> module, event classes are specified by dictionaries
of key-value pairs
describing the rate events of a particular class happen, the type of event
and the parameters unique to each event class. Each dictionary must have
two fields: <tt class="docutils literal"><span class="pre">rate</span></tt> and <tt class="docutils literal"><span class="pre">type</span></tt>. The <tt class="docutils literal"><span class="pre">rate</span></tt> field specifies the rate
that this class of events happens at and is a float. The <tt class="docutils literal"><span class="pre">type</span></tt> field
specifies the type of events. The supported event classes are:</p>
<dl class="docutils">
<dt>Disc Events</dt>
<dd>Events from the disc model have <tt class="docutils literal"><span class="pre">type</span></tt> equal to DISC_EVENT_CLASS and
two further fields: <tt class="docutils literal"><span class="pre">r</span></tt> is a double value specifying the radius of
the event and <tt class="docutils literal"><span class="pre">u</span></tt> is a double value specifying the impact of the event.
Example: <cite>{&#8220;type&#8221;:DISC_EVENT_CLASS, &#8220;rate&#8221;:1.0, &#8220;r&#8221;:2.0,
&#8220;u&#8221;:0.5}</cite></dd>
<dt>Gaussian Events</dt>
<dd>Events from the Gaussian model have <tt class="docutils literal"><span class="pre">type</span></tt> equal to GAUSSIAN_EVENT_CLASS
and three further fields: <tt class="docutils literal"><span class="pre">theta</span></tt> specifies the size of the event,
<tt class="docutils literal"><span class="pre">alpha</span></tt> the relative location of parents and <tt class="docutils literal"><span class="pre">u0</span></tt> the impact.
Example: <cite>{&#8220;type&#8221;:GAUSSIAN_EVENT_CLASS, &#8220;rate&#8221;:1.0, &#8220;theta&#8221;:2.0,
&#8220;u0&#8221;:0.5, &#8220;alpha&#8221;:0.75}</cite></dd>
</dl>
</div>
<div class="section" id="bibliography">
<h2><a class="toc-backref" href="#id27">Bibliography</a><a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="e08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[E08]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> A. Etheridge. Drift, draft and structure: some mathematical models of evolution,
<em>Banach Center Publications</em> 80, pp 121&#8211;144, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bev10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BEV10]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> N. H.  Barton,  A. M. Etheridge and A. Véber.
A new model for evolution in a spatial continuum, <em>Electronic Journal of
Probability</em> 15:7, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bke10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BKE10]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> N. H.  Barton,  J. Kelleher and A. M. Etheridge.
A new model for extinction and recolonisation in two dimensions: quantifying phylogeography,
<em>Evolution</em>, 64(9), pp 2701&#8211;2715, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bev12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BEV12]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id9">2</a>, <a class="fn-backref" href="#id11">3</a>)</em> N. H.  Barton,  A. M. Etheridge and A. Véber.
Modelling Evolution in a Spatial continuum,
<em>J. Stat. Mech.</em>, to appear, 2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="k11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[K11]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> D. E. Knuth, Combinatorial Algorithms, Part 1; Volume 4A of <em>The Art of Computer
Programming</em>, 2011.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1><a class="toc-backref" href="#id28">Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Extinction/recolonisation coalescent simulator</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#samples">Samples</a></li>
<li><a class="reference internal" href="#oriented-trees-and-forests">Oriented trees and forests</a></li>
<li><a class="reference internal" href="#coalescence-times-and-mrcas">Coalescence times and MRCAs</a></li>
<li><a class="reference internal" href="#multiple-loci">Multiple loci</a></li>
</ul>
</li>
<li><a class="reference internal" href="#estimating-identity">Estimating identity</a></li>
<li><a class="reference internal" href="#module-ercs"><tt class="docutils literal"><span class="pre">ercs</span></tt> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#ercs-simulator"><tt class="docutils literal"><span class="pre">ercs.Simulator</span></tt></a></li>
<li><a class="reference internal" href="#event-classes">Event Classes</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-_ercs"><tt class="docutils literal"><span class="pre">_ercs</span></tt> &#8211; Module reference</a></li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">ercs 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jerome Kelleher.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>