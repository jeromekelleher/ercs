

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Extinction/recolonisation coalescent simulator &mdash; ercs 1.0.4-dev documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.4-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="ercs 1.0.4-dev documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">ercs 1.0.4-dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="extinction-recolonisation-coalescent-simulator">
<h1><a class="toc-backref" href="#id14">Extinction/recolonisation coalescent simulator</a><a class="headerlink" href="#extinction-recolonisation-coalescent-simulator" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#extinction-recolonisation-coalescent-simulator" id="id14">Extinction/recolonisation coalescent simulator</a><ul>
<li><a class="reference internal" href="#introduction" id="id15">Introduction</a></li>
<li><a class="reference internal" href="#examples" id="id16">Examples</a><ul>
<li><a class="reference internal" href="#basic-usage" id="id17">Basic usage</a></li>
<li><a class="reference internal" href="#samples" id="id18">Samples</a></li>
<li><a class="reference internal" href="#oriented-trees-and-forests" id="id19">Oriented trees and forests</a></li>
<li><a class="reference internal" href="#coalescence-times-and-mrcas" id="id20">Coalescence times and MRCAs</a></li>
<li><a class="reference internal" href="#multiple-loci" id="id21">Multiple loci</a></li>
<li><a class="reference internal" href="#draft" id="id22">DRAFT</a></li>
<li><a class="reference internal" href="#a-full-example" id="id23">A full example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-ercs" id="id24"><a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#event-classes" id="id25">Event Classes</a></li>
<li><a class="reference internal" href="#ercs-simulator" id="id26"><a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a></a></li>
<li><a class="reference internal" href="#utilities" id="id27">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13" id="id28"><a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#low-level-event-classes" id="id29">Low Level Event Classes</a></li>
<li><a class="reference internal" href="#simulation-interface" id="id30">Simulation interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bibliography" id="id31">Bibliography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables" id="id32">Indices and tables</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id15">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The extinction/recolonisation model (or the spatial Lambda-Fleming-Viot process)
is a recently-introduced model of populations evolving in continuous space.
In this model, individuals occupy a fixed location and all movement and
reproduction occur as a result of extinction/recolonisation <em>events</em>. Events
fall randomly in space, independent of the location of extant individuals.
In each event, some of the nearby individuals
die and are replaced by the descendants of a small
number of parents, drawn randomly from the population immediately
before the event.  See <a class="reference internal" href="#e08">[E08]</a>, <a class="reference internal" href="#bev10">[BEV10]</a>, <a class="reference internal" href="#bke10">[BKE10]</a>  and <a class="reference internal" href="#bev12">[BEV12]</a> for
discussions of the model, its background, and detailed mathematical
results.</p>
<p>This is the documentation for the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> Python module,
which provides a straightforward interface to coalescent simulations
for this model. The basic approach to simulating
the history of a sample and interpreting the results is explained through
a series of straightforward examples in the <a class="reference internal" href="#examples">Examples</a>  section
along with thorough API documentation for the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module.</p>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id16">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Simulating the coalescent for the extinction/recolonisation model using
<a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> follows a basic pattern:</p>
<ol class="arabic simple">
<li>Allocate an instance of <a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a>;</li>
<li>Set the properties of the desired simulation by assigning values to the
attributes of this object;</li>
<li>Run the simulation for a given random seed using the <a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a>
method;</li>
<li>Analyse the resulting genealogies to obtain the information of interest.</li>
</ol>
<p>In the following examples we look at the parameters of the simulation, the
structure of the simulated genealogies (and how we can analyse them) and
how we can use these tools to estimate values of interest.</p>
<div class="section" id="basic-usage">
<h3><a class="toc-backref" href="#id17">Basic usage</a><a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>To simulate the history of a set of individuals at a sample of
locations on a 2D torus, we first allocate an instance of the
<a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a> class. This class has a number of attributes
which can be set to describe the parameters of the desired simulation.
Most of these parameters have sensible defaults, but we must specify
at least three of these before we can run a simulation. Here is a
simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ercs</span>

<span class="k">def</span> <span class="nf">first_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span>  <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example we allocate a simulator on a torus of diameter 20,
set up our sample and event classes, run the simulation
and the resulting genealogy. The size of the torus is
rather arbitrary, as the real size of the habitat that
we imagine our population evolving on is determined by the scale
of events relative to the size of the torus. Thus, the size of the
torus can be any value you wish, once the spatial extent of events
is scaled appropriately.</p>
<p>The details of the model under which we imagine the population has evolved
are specified via one or more <em>event classes</em>.
We allocate a list of objects
that describe the type of events that we
are interested in, and assign these to the
<a class="reference internal" href="#ercs.Simulator.event_classes" title="ercs.Simulator.event_classes"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.event_classes</span></tt></a> attribute. In the example above,
we state that all events in the simulation are from the Disc model,
and they have radius <tt class="docutils literal"><span class="pre">r</span> <span class="pre">=</span>&nbsp; <span class="pre">1</span></tt> and impact <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">0.5</span></tt>.
There can be any number of event classes happening at different
rates: see <a class="reference internal" href="#event-classes">Event Classes</a> for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In these examples we&#8217;ll tend to
use rather large events, as it&#8217;s useful to have examples that
run quickly. These represent highly unrealistic evolutionary scenarios.</p>
</div>
</div>
<div class="section" id="samples">
<h3><a class="toc-backref" href="#id18">Samples</a><a class="headerlink" href="#samples" title="Permalink to this headline">¶</a></h3>
<p>The initial locations of the lineages whose ancestry we wish to simulate
are specified using the <a class="reference internal" href="#ercs.Simulator.sample" title="ercs.Simulator.sample"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.sample</span></tt></a> attribute, which is a list of
2-tuples describing locations on the torus.
There is a slightly awkward issue to deal with about how we use this list,
however.</p>
<p>In the simulation algorithm, locations in the sample are mapped to the
positive integers, <tt class="docutils literal"><span class="pre">1</span></tt> to <tt class="docutils literal"><span class="pre">n</span></tt>. These integers represent the nodes
that the lineage occupies in the tree describing the history of the
sample, and this relationship is most simply described using a list.
The awkwardness arises in the discrepancy between this convention of
counting from <tt class="docutils literal"><span class="pre">1</span></tt> and Python&#8217;s convention of making the index of
the first element of a list <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>To avoid inconsistencies between the input and output of the simulations,
we therefore adopt the convention that the zero&#8217;th element of the sample
must be <tt class="docutils literal"><span class="pre">None</span></tt>. So, in the sample above we simulate the history of
three locations <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt>, <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">5)</span></tt> and <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">10)</span></tt>, which are
mapped to nodes <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt> respectively. Writing the
mapping out explicitly we get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)}</span>
<span class="go">{1: (0, 0), 2: (0, 5), 3: (0, 10)}</span>
</pre></div>
</div>
</div>
<div class="section" id="oriented-trees-and-forests">
<h3><a class="toc-backref" href="#id19">Oriented trees and forests</a><a class="headerlink" href="#oriented-trees-and-forests" title="Permalink to this headline">¶</a></h3>
<p>After we have completed setting up the parameters of the simulation
we can then run the simulation by calling the
<a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a> method for a given random seed.
Running the example above, we get</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">first_example</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([[-1, 4, 4, 5, 5, 0]], [[-1, 0.0, 0.0, 0.0, 30441.574004183603, 46750.11224375103]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is nothing special about the seed 3 here&#8212;it is just a value which
produced a neat example to discuss.</p>
</div>
<p>This output completely describes the ancestry of the sample, although it&#8217;s not immediately
obvious how. In <tt class="docutils literal"><span class="pre">ercs</span></tt> we use <em>oriented trees</em> to represent the genealogy of a sample.
In an oriented tree, we are only interested in parent-child relationships
and don&#8217;t care about the order of children at a node. Therefore, in an oriented tree
<tt class="docutils literal"><span class="pre">pi</span></tt>, the parent of node <tt class="docutils literal"><span class="pre">j</span></tt> is <tt class="docutils literal"><span class="pre">pi[j]</span></tt>. If we map each node in the tree to a unique
positive integer and adopt the convention that any node whose parent is the
special &#8220;null node&#8221; <tt class="docutils literal"><span class="pre">0</span></tt> is a root,
we can then represent an oriented tree very simply as a list of integers.</p>
<p>The <a class="reference internal" href="#ercs.Simulator.run" title="ercs.Simulator.run"><tt class="xref py py-meth docutils literal"><span class="pre">ercs.Simulator.run()</span></tt></a> method returns a tuple, <tt class="docutils literal"><span class="pre">(pi,</span> <span class="pre">tau)</span></tt>;
<tt class="docutils literal"><span class="pre">pi</span></tt> is a list of oriented forests (one for each locus) and <tt class="docutils literal"><span class="pre">tau</span></tt> is a list of
node times (one for each locus). In the example, we are dealing with a single locus
only, so <tt class="docutils literal"><span class="pre">pi</span></tt> is a list consisting of one list, <tt class="docutils literal"><span class="pre">[-1,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">5,</span> <span class="pre">0]</span></tt>, that
encodes the following tree:</p>
<img alt="An oriented tree" class="align-center" src="_images/oriented-tree.png" style="width: 15cm;" />
<p>The leaf nodes <tt class="docutils literal"><span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">2</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt> correspond to the locations in our sample
as discussed above.
Mapping all nodes in the oriented tree to their parents explicitly, we get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">first_example</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]))}</span>
<span class="go">{1: 4, 2: 4, 3: 5, 4: 5, 5: 0}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The zero&#8217;th element of an oriented forest and its associated node
time list is not used and is set to -1 by convention,
following Knuth (Algorithm O, section 7.2.1.6) <a class="reference internal" href="#k11">[K11]</a>.</p>
</div>
<p>The times labelled on the tree are derived from the node times list for this
locus, <tt class="docutils literal"><span class="pre">tau[0]</span></tt>. The node times list associated with an oriented tree
records the time that the associated lineage entered the sample, looking
backwards in time (hence, for each node in the sample the time is <tt class="docutils literal"><span class="pre">0.0</span></tt>).</p>
<p>Oriented <em>forests</em> occur when there is more than one root in a list <tt class="docutils literal"><span class="pre">pi</span></tt>, and
so we have a set of disconnected trees. This can happen when we specify
the <a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a> attribute, potentially stopping the simulation before
the sample has completely coalesced. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">oriented_forest_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="mf">1e5</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Here we allocate a Simulator on a torus of diameter 20 as before and
use the usual event class. This time we allocate a sample of size 10,
arranged regularly along a line, and stipulate that the simulation should
continue for no more then 10<sup>5</sup> time units. As we&#8217;re only
interested in the structure of the genealogy this time, we just
return the oriented forest at the first locus. Running this, we get</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">oriented_forest_example</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[-1, 0, 15, 0, 12, 12, 13, 11, 13, 11, 16, 16, 14, 14, 15, 0, 0]</span>
</pre></div>
</div>
<p>In this forest there are <em>four</em> roots: 1, 3, 15 and 16.</p>
<img alt="An oriented forest" class="align-center" src="_images/oriented-forest.png" style="width: 15cm;" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This forest is <strong>not</strong> a correct representation of the
node times; in any simulation, node <tt class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></tt> cannot be more recent
than node <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
</div>
</div>
<div class="section" id="coalescence-times-and-mrcas">
<h3><a class="toc-backref" href="#id20">Coalescence times and MRCAs</a><a class="headerlink" href="#coalescence-times-and-mrcas" title="Permalink to this headline">¶</a></h3>
<p>In coalescent simulations we are usually interested in the
coalescence time of two or more lineages in our sample,
which is the time back to their most recent
recent common ancestor (MRCA).
This is straightforward to do in <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> using the
<a class="reference internal" href="#ercs.MRCACalculator" title="ercs.MRCACalculator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.MRCACalculator</span></tt></a> class to find the most recent
common ancestor of two nodes and then looking up the node
times list to find the time that this node entered the sample.</p>
<p>In the following example, we print out the pairwise coalescence
time for a sample of size 4:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mrca_example</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">mc</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">MRCACalculator</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;pi  = &quot;</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;tau = &quot;</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mrca</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mrca</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">mrca({0}, {1}) = {2} @ {3:.2f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mrca</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mrca_example</span><span class="p">(</span><span class="mi">10292</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">pi  =  [[-1, 5, 5, 6, 6, 7, 7, 0]]</span>
<span class="go">tau =  [[-1, 0.0, 0.0, 0.0, 0.0, 1495.7013764597423, 51935.87882804881, 231859.81270041558]]</span>
<span class="go">        mrca(1, 2) = 5 @ 1495.70</span>
<span class="go">        mrca(1, 3) = 7 @ 231859.81</span>
<span class="go">        mrca(1, 4) = 7 @ 231859.81</span>
<span class="go">        mrca(2, 3) = 7 @ 231859.81</span>
<span class="go">        mrca(2, 4) = 7 @ 231859.81</span>
<span class="go">        mrca(3, 4) = 6 @ 51935.88</span>
</pre></div>
</div>
<p>Here we can see, for example, that the MRCA of nodes <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">2</span></tt> is <tt class="docutils literal"><span class="pre">5</span></tt>
which can be read directly from <tt class="docutils literal"><span class="pre">pi</span></tt>, as it is also their parent. Then,
reading the time of node <tt class="docutils literal"><span class="pre">5</span></tt> from <tt class="docutils literal"><span class="pre">tau</span></tt> we see that their coalescence
time is 1495.70.</p>
</div>
<div class="section" id="multiple-loci">
<h3><a class="toc-backref" href="#id21">Multiple loci</a><a class="headerlink" href="#multiple-loci" title="Permalink to this headline">¶</a></h3>
<p>In the extinction/recolonisation model
recombination rates are specified by
describing the probability that two adjacent loci <tt class="docutils literal"><span class="pre">l</span></tt>
and <tt class="docutils literal"><span class="pre">l</span> <span class="pre">+</span> <span class="pre">1</span></tt> descend from different parents at an event. Therefore, in
a system of <tt class="docutils literal"><span class="pre">m</span></tt> loci, we need a list of <tt class="docutils literal"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">1</span></tt> recombination
probabilities to describe the system in a general way.</p>
<p>The <a class="reference internal" href="#ercs.Simulator.recombination_probabilities" title="ercs.Simulator.recombination_probabilities"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.recombination_probabilities</span></tt></a> attribute is used
to describe both the number of loci and the recombination rates between them.
By default, this attribute is set to the empty list, specifying a single
locus system. In the following example
we compute the joint probability of identity in state given a mutation
rate <tt class="docutils literal"><span class="pre">mu</span></tt> at two loci in a single
replicate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">two_locus_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">1e-7</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">recombination_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Since our sample is of size two, the MRCA of nodes <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">2</span></tt> must
be <tt class="docutils literal"><span class="pre">3</span></tt>. The probability of identity in state for two genes with coalescence
time <tt class="docutils literal"><span class="pre">t</span></tt> and mutation at rate <tt class="docutils literal"><span class="pre">mu</span></tt>
under the infinite sites model is <tt class="docutils literal"><span class="pre">exp(-2</span> <span class="pre">*</span> <span class="pre">mu</span> <span class="pre">*</span> <span class="pre">t)</span></tt>. The joint probability
of identity is then the product of the probability of identity at
each locus.</p>
<p>Running this example gives us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">two_locus_example</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="go">0.06931300943428219</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Loci are zero-indexed in the usual Python way, unlike individuals
in the sample.</p>
</div>
<p>The example above shows how we can simulate two loci, and can be generalised
to larger numbers of loci in a straightforward way. However, since the number
of lineages can grow to be very large when we deal with large numbers of loci,
it may be necessary to become more familiar with some more advanced properties
of the simulation implementation.</p>
<p>The first issue is to decide how much memory you are willing to dedicate
to the task of tracking lineages; this is done by specifiying the maximum
number of lineages in the sample using the
<a class="reference internal" href="#ercs.Simulator.max_lineages" title="ercs.Simulator.max_lineages"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_lineages</span></tt></a> attribute.
When the number of lineages in the sample
exceeds this limit, the simulation fails with an exception, as
illustrated in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">out_of_memory_example</span><span class="p">():</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">max_lineages</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">recombination_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">499</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out_of_memory_example</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;example.py&quot;</span>, line <span class="m">77</span>, in <span class="n">out_of_memory_example</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  File <span class="nb">&quot;ercs.py&quot;</span>, line <span class="m">116</span>, in <span class="n">run</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gr">_ercs.LibraryError</span>: <span class="n">Out of lineage memory</span>
</pre></div>
</div>
<p>The example fails because we try to simulate the
ancestry of two 500 locus individuals with a limit of only 10 extant individuals.
If we wish to simulate the entire history of the sample, we must increase
the number maximum number of lineages. On the other hand, if we are only
interested in the recent history of the sample, we can stop the simulation
before the sample gets too large using the <a class="reference internal" href="#ercs.Simulator.max_time" title="ercs.Simulator.max_time"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_time</span></tt></a>
attribute.</p>
<p>Lineages are indexed using a kdtree to allow us to find
the lineages that may potentially be hit by an event
efficiently. The
<a class="reference internal" href="#ercs.Simulator.kdtree_bucket_size" title="ercs.Simulator.kdtree_bucket_size"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.kdtree_bucket_size</span></tt></a>
<a class="reference internal" href="#ercs.Simulator.max_kdtree_insertions" title="ercs.Simulator.max_kdtree_insertions"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.max_kdtree_insertions</span></tt></a>
attributes provide a means of tuning this data structure for
performance when very large numbers of lineages are involved.</p>
</div>
<div class="section" id="draft">
<h3><a class="toc-backref" href="#id22">DRAFT</a><a class="headerlink" href="#draft" title="Permalink to this headline">¶</a></h3>
<p>Everything below this point is in development.</p>
</div>
<div class="section" id="a-full-example">
<h3><a class="toc-backref" href="#id23">A full example</a><a class="headerlink" href="#a-full-example" title="Permalink to this headline">¶</a></h3>
<p>Up to this point we have considered models in which a single class
of event occurs at rate 1.0. We can simulate an arbitrary number
of event classes happening at different rates, however; we simply
set the <a class="reference internal" href="#ercs.Simulator.event_classes" title="ercs.Simulator.event_classes"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.event_classes</span></tt></a> attribute to a list
consisting of <a class="reference internal" href="#ercs.EventClass" title="ercs.EventClass"><tt class="xref py py-class docutils literal"><span class="pre">ercs.EventClass</span></tt></a> instances with the required rates and
properties.</p>
<p>For example, Figure 2 of <a class="reference internal" href="#bev12">[BEV12]</a>  plots the probability of identity in
state for three event regimes: one in which we have small events only;
another in which we have large events only; and finally a regime
in which we have a mixture of the two. The following example
returns the probability of identity for evenly spaced samples in a
single replicate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mixed_events_example</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">sv</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">MRCACalculator</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c"># TODO  Fill me in.</span>
</pre></div>
</div>
<p>The most common use of coalescent simulation is to estimate the distribution
of some quantity by aggregating over many different replicates. This is
done in <tt class="docutils literal"><span class="pre">ercs</span></tt> by running the <tt class="docutils literal"><span class="pre">run</span></tt> method with different random
seeds, one for each replicate. Since each replicate is then completely
independent, we can easily parallelise the process. One possible way
to this is using the <a class="reference external" href="http://docs.python.org/2.6/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.6)"><tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></tt></a> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ercs</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="k">def</span> <span class="nf">parallel_run</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">ercs</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">event_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ercs</span><span class="o">.</span><span class="n">DiscEventClass</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">coal_time</span> <span class="o">=</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">coal_time</span>

<span class="k">def</span> <span class="nf">parallel_example</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="n">coal_times</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parallel_run</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_replicates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coal_times</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_replicates</span>
</pre></div>
</div>
<p>In this example we are working on a torus of diameter 100, so the simulations
require a lot longer to run. On most modern systems we have many CPU cores,
and so we use the multiprocessing module to distribute the work of many
replicates across these cores.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parallel_example</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">2968953.9276501946</span>
</pre></div>
</div>
<p>This is the mean coalescence time among 100 replicates. The multiprocessing
module runs <tt class="docutils literal"><span class="pre">parallel_run</span></tt> function for each of the seeds in
a subprocess and collects the coalescence times into the list
<tt class="docutils literal"><span class="pre">coal_times</span></tt>. We then take the mean of this list and return it.
The random seeds are simply the integers from 1 to 100. This is a perfectly
legitimate way to choose seeds for a single example, since the random
sequences for adjacent seeds are not correlated. If, however, we are
are doing lots of simulations with different parameter values or are
distributing our simulations over several machines, it would be better
to spread our choice of seeds out more evenly across the possible space.
One way to do this is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
</pre></div>
</div>
<p>There is no issue with using the Python random generator within your
code, as the <tt class="docutils literal"><span class="pre">ercs</span></tt> C library generates random numbers independently
of Python (using the <tt class="docutils literal"><span class="pre">mt19937</span></tt> random number generator from the
<a class="reference external" href="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">GNU Scientific Library</a>).</p>
</div>
</div>
<div class="section" id="module-ercs">
<span id="ercs-module-reference"></span><h2><a class="toc-backref" href="#id24"><a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> &#8211; Module reference</a><a class="headerlink" href="#module-ercs" title="Permalink to this headline">¶</a></h2>
<p>Simulate the coalescent in the extinction recolonisation model under a 
flexible set of parameters.</p>
<div class="section" id="event-classes">
<h3><a class="toc-backref" href="#id25">Event Classes</a><a class="headerlink" href="#event-classes" title="Permalink to this headline">¶</a></h3>
<p>The classes of event in a given simulation are specified by
providing a list of Event Class instances
in the <a class="reference internal" href="#ercs.Simulator.event_classes" title="ercs.Simulator.event_classes"><tt class="xref py py-attr docutils literal"><span class="pre">ercs.Simulator.event_classes</span></tt></a> attribute.
Two classes of event are currently supported:
the Disc model and the Gaussian model. See <a class="reference internal" href="#e08">[E08]</a>, <a class="reference internal" href="#bev10">[BEV10]</a>, <a class="reference internal" href="#bev12">[BEV12]</a>
and several other articles for details of the Disc model, and see
<a class="reference internal" href="#bke10">[BKE10]</a> and <a class="reference internal" href="#bev12">[BEV12]</a> for details of the Gaussian model.</p>
<dl class="class">
<dt id="ercs.EventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">EventClass</tt><big>(</big><em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.EventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing the an Event Class in the extinction/recolonisation model. 
Events of a particular class occur at a specific rate and have fixed parameters,
the details of which depend on the specific model.</p>
</dd></dl>

<dl class="class">
<dt id="ercs.DiscEventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">DiscEventClass</tt><big>(</big><em>r</em>, <em>u</em>, <em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.DiscEventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing events from the Disc model, in which all individuals within
distance <em>r</em> of the centre of an event have probability <em>u</em> of dying in the 
event and parents are thrown down uniformly within this disc.</p>
</dd></dl>

<dl class="class">
<dt id="ercs.GaussianEventClass">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">GaussianEventClass</tt><big>(</big><em>theta</em>, <em>alpha</em>, <em>u0</em>, <em>rate=1.0</em><big>)</big><a class="headerlink" href="#ercs.GaussianEventClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing events from the Gaussian model, in which an individual at  
distance <em>d</em> of the centre of the event have probability 
<img class="math" src="_images/math/cce1afa36a021361aede55e0453e74264871da87.png" alt="u_0\exp(-d^2/(2\theta^2))"/> of dying in the event. Parents are thrown down 
around the centre of the event according to a 2D Gaussian with variance 
<img class="math" src="_images/math/ce130d89991915e0f88bd671d4cb36bcadaa7a80.png" alt="\theta^2\alpha^2"/>.</p>
</dd></dl>

</div>
<div class="section" id="ercs-simulator">
<h3><a class="toc-backref" href="#id26"><a class="reference internal" href="#ercs.Simulator" title="ercs.Simulator"><tt class="xref py py-class docutils literal"><span class="pre">ercs.Simulator</span></tt></a></a><a class="headerlink" href="#ercs-simulator" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="ercs.Simulator">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">Simulator</tt><big>(</big><em>torus_diameter</em><big>)</big><a class="headerlink" href="#ercs.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a coalescent simulator for the extinction/recolonisation
model on a torus of the specified diameter.</p>
<p>The class provides a convenient interface to the low-level <a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a>
module, and contains instance variables for each of the simulation 
parameters with sensible defaults. These parameters should be set 
before calling simulate.</p>
<dl class="attribute">
<dt id="ercs.Simulator.sample">
<tt class="descname">sample</tt><a class="headerlink" href="#ercs.Simulator.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>The location of lineages at the beginning of the simulation. This
must be a list of 2-tuples describing locations
within the 2D space defined by the torus. The zero&#8217;th element
of this list <strong>must be</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p><strong>Default value:</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.event_classes">
<tt class="descname">event_classes</tt><a class="headerlink" href="#ercs.Simulator.event_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>The event classes to simulate. This must be a list of
<a class="reference internal" href="#ercs.EventClass" title="ercs.EventClass"><tt class="xref py py-class docutils literal"><span class="pre">ercs.EventClass</span></tt></a>
instances. There must be at least one event class specified.</p>
<p><strong>Default value:</strong> <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.torus_diameter">
<tt class="descname">torus_diameter</tt><a class="headerlink" href="#ercs.Simulator.torus_diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>The diameter of the torus we are simulating on. This defines the
size of the space that lineages can move around in.</p>
<p><strong>Default value:</strong> Specified at substantiation time.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.num_parents">
<tt class="descname">num_parents</tt><a class="headerlink" href="#ercs.Simulator.num_parents" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parents in each event. For a single locus simulation
there must be at least one parent and for multi-locus simulations
at least two.</p>
<p><strong>Default value:</strong> 1 if the simulation is single locus, otherwise 2.</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.recombination_probabilities">
<tt class="descname">recombination_probabilities</tt><a class="headerlink" href="#ercs.Simulator.recombination_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of inter-locus recombination probabilities; the length of
this list also determines the number of loci for each individual.
At an event, the probability of locus <tt class="docutils literal"><span class="pre">j</span></tt> and <tt class="docutils literal"><span class="pre">j</span> <span class="pre">+</span> <span class="pre">1</span></tt> descending
from different parents is <tt class="docutils literal"><span class="pre">recombination_probabilities[j]</span></tt>.
The number of loci in the simulation is therefore
<tt class="docutils literal"><span class="pre">len(recombination_probabilities)</span> <span class="pre">+</span> <span class="pre">1</span></tt>.</p>
<p><strong>Default value:</strong> The empty list [] (so, we have a single locus
simulation by default).</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_time">
<tt class="descname">max_time</tt><a class="headerlink" href="#ercs.Simulator.max_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum amount of time (in simulation units) that we simulate. If
this is set to <cite>0.0</cite> the simulation continues until all loci have
coalesced.</p>
<p><strong>Default value:</strong> 0.0</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_lineages">
<tt class="descname">max_lineages</tt><a class="headerlink" href="#ercs.Simulator.max_lineages" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of extant lineages in the simulation.
If the number of lineages we are tracking exceeds this limit,
the simulation aborts and raises an <tt class="xref py py-exc docutils literal"><span class="pre">_ercs.LibraryError</span></tt>.</p>
<p><strong>Default value:</strong> 1000</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.kdtree_bucket_size">
<tt class="descname">kdtree_bucket_size</tt><a class="headerlink" href="#ercs.Simulator.kdtree_bucket_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of locations in a leaf node of the kdtree; must be a power of
two, greater than 0. The <tt class="docutils literal"><span class="pre">kdtree_bucket_size</span></tt>
is an advanced parameter that may be useful in tuning performance when very
large numbers of lineages are involved. Larger values will result in less
time and memory spent indexing the lineages, but more lineages will need to
be tested to see if they are within the critical radius of the event. <strong>Note:</strong>
changing this parameter affects the outcome of simulations! That is, if we
change the value of the bucket size, we cannot expect the outcome of two
simulations with the same random seed to be the same. The reason for this
is that, although we are guaranteed to end up with the same set of lineages
in an event in any case, the <em>order</em> in which they die may be different,
pushing the simulation onto a different stochastic trajectory.</p>
<p><strong>Default value:</strong> 1</p>
</dd></dl>

<dl class="attribute">
<dt id="ercs.Simulator.max_kdtree_insertions">
<tt class="descname">max_kdtree_insertions</tt><a class="headerlink" href="#ercs.Simulator.max_kdtree_insertions" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of insertions into the kdtree before a rebuild, or
0 if the tree is not to be rebuilt. This parameter is useful for tuning the
performance of the simulation when
we have large numbers of loci, particularly if we begin with a relatively
small sample. In this case, as the number of lineages increases over time
and they spread outwards to cover more and more of the torus, we need to
rebuild the index periodically. If we begin with a large sample uniformly
distributed around the space then this can safely be set to 0.</p>
<p><strong>Default value:</strong> 0</p>
</dd></dl>

<dl class="method">
<dt id="ercs.Simulator.run">
<tt class="descname">run</tt><big>(</big><em>random_seed</em><big>)</big><a class="headerlink" href="#ercs.Simulator.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the coalescent simulation for the specified random seed, 
and returns the simulated history, (pi, tau). The history consists
of a list of oriented forests (one for each locus) and their
corresponding node times (one for each locus).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random_seed</strong> (<em>integer.</em>) &#8211; the value to initialise the random number
generator</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the simulated history of the sample, (pi, tau)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a tuple <tt class="docutils literal"><span class="pre">(pi,</span> <span class="pre">tau)</span></tt>; <tt class="docutils literal"><span class="pre">pi</span></tt> is a list of lists of integers, 
and <tt class="docutils literal"><span class="pre">tau</span></tt> is a list of lists of doubles</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">_ercs.InputError</span></tt> when the input is not correctly formed</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><tt class="xref py py-exc docutils literal"><span class="pre">_ercs.LibraryError</span></tt> when the C library encounters an 
error</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="utilities">
<h3><a class="toc-backref" href="#id27">Utilities</a><a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="ercs.torus_distance">
<tt class="descclassname">ercs.</tt><tt class="descname">torus_distance</tt><big>(</big><em>x</em>, <em>y</em>, <em>L</em><big>)</big><a class="headerlink" href="#ercs.torus_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Euclidean distance between two points x and y on a 2D
square torus with diameter L.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>two-tuple of numeric values</em>) &#8211; first point</li>
<li><strong>y</strong> (<em>two-tuple of numeric values</em>) &#8211; second point</li>
<li><strong>L</strong> &#8211; torus diameter</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">floating point value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="ercs.MRCACalculator">
<em class="property">class </em><tt class="descclassname">ercs.</tt><tt class="descname">MRCACalculator</tt><big>(</big><em>oriented_forest</em><big>)</big><a class="headerlink" href="#ercs.MRCACalculator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to that allows us to compute the nearest common ancestor of arbitrary
nodes in an oriented forest.</p>
<p>This is an implementation of Schieber and Vishkin&#8217;s nearest common ancestor 
algorithm from TAOCP volume 4A, pg.164-167 <a class="reference internal" href="#k11">[K11]</a>. Preprocesses the 
input tree into a sideways heap in O(n) time and processes queries for the 
nearest common ancestor between an arbitary pair of nodes in O(1) time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>oriented_forest</strong> (<em>list of integers</em>) &#8211; the input oriented forest</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ercs.MRCACalculator.get_mrca">
<tt class="descname">get_mrca</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#ercs.MRCACalculator.get_mrca" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the most recent common ancestor of the nodes x and y, 
or 0 if the nodes belong to different trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>positive integer</em>) &#8211; the first node</li>
<li><strong>y</strong> (<em>positive integer</em>) &#8211; the second node</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the MRCA of nodes x and y</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type :</th><td class="field-body"><p class="first last">non-negative integer</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id28"><a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a> &#8211; Module reference</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module delegates the majority of its work to the low-level <a class="reference internal" href="#module-_ercs" title="_ercs"><tt class="xref py py-mod docutils literal"><span class="pre">_ercs</span></tt></a>
extension module, which is written in C. It is not recommended to call this
module directly - the <a class="reference internal" href="#module-ercs" title="ercs"><tt class="xref py py-mod docutils literal"><span class="pre">ercs</span></tt></a> module provides all of the functionality with a
much more straightforward interface. In the interested of completeness,
however, the low-level module is documented here.</p>
<span class="target" id="module-_ercs"></span><div class="section" id="low-level-event-classes">
<h3><a class="toc-backref" href="#id29">Low Level Event Classes</a><a class="headerlink" href="#low-level-event-classes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>In the <tt class="docutils literal"><span class="pre">_ercs</span></tt> module, event classes are specified by dictionaries  of key-value pairs  describing the rate events of a particular class happen, the type of event  and the parameters unique to each event class. Each dictionary must have two fields: <tt class="docutils literal"><span class="pre">rate</span></tt> and <tt class="docutils literal"><span class="pre">type</span></tt>. The <tt class="docutils literal"><span class="pre">rate</span></tt> field specifies the rate that this class of events happens at and is a float. The <tt class="docutils literal"><span class="pre">type</span></tt> field  specifies the type of events. The supported event classes are:</div></blockquote>
<dl class="docutils">
<dt>Disc Events</dt>
<dd>Events from the disc model have <tt class="docutils literal"><span class="pre">type</span></tt> equal to DISC_EVENT_CLASS and    two further fields: <tt class="docutils literal"><span class="pre">r</span></tt> is a double value specifying the radius of    the event and <tt class="docutils literal"><span class="pre">u</span></tt> is a double value specifying the impact of the event.   Example: <cite>{&#8220;type&#8221;:DISC_EVENT_CLASS, &#8220;rate&#8221;:1.0, &#8220;r&#8221;:2.0,    &#8220;u&#8221;:0.5}</cite></dd>
<dt>Gaussian Events</dt>
<dd>Events from the Gaussian model have <tt class="docutils literal"><span class="pre">type</span></tt> equal to GAUSSIAN_EVENT_CLASS    and three further fields: <tt class="docutils literal"><span class="pre">theta</span></tt> specifies the size of the event,    <tt class="docutils literal"><span class="pre">alpha</span></tt> the relative location of parents and <tt class="docutils literal"><span class="pre">u0</span></tt> the impact.    Example: <cite>{&#8220;type&#8221;:GAUSSIAN_EVENT_CLASS, &#8220;rate&#8221;:1.0, &#8220;theta&#8221;:2.0,    &#8220;u0&#8221;:0.5, &#8220;alpha&#8221;:0.75}</cite></dd>
</dl>
</div>
<div class="section" id="simulation-interface">
<h3><a class="toc-backref" href="#id30">Simulation interface</a><a class="headerlink" href="#simulation-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_ercs.simulate">
<tt class="descclassname">_ercs.</tt><tt class="descname">simulate</tt><big>(</big><big>)</big><a class="headerlink" href="#_ercs.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates an ercs object from the C library, calls the simulate function and returns the resulting genealogy. All arguments must be specified and be in the correct order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>random_seed</strong> (<em>long integer</em>) &#8211; The seed used for the GSL random generator</li>
<li><strong>torus_diameter</strong> (<em>double</em>) &#8211; The diameter of the torus</li>
<li><strong>num_parents</strong> (<em>unsigned integer</em>) &#8211; The number of parents in each event</li>
<li><strong>sample</strong> (<em>list of numeric (x, y) tuples</em>) &#8211; The sample of 2D locations</li>
<li><strong>event_classes</strong> (list of dictionaries; see        <a class="reference internal" href="#low-level-event-classes">Low Level Event Classes</a>) &#8211; The list of event classes and their rates</li>
<li><strong>recombination_probabilities</strong> (<em>list of doubles</em>) &#8211; probability of recombination between       adjacent loci</li>
<li><strong>kdtree_bucket_size</strong> (<em>unsigned integer</em>) &#8211; The number of points in a kdtree bucket</li>
<li><strong>max_kdtree_insertions</strong> (<em>unsigned integer</em>) &#8211; The maximum number of insertions before        the kdtree is rebuilt. If this parameter is 0 then the kdtree will        not be rebuilt</li>
<li><strong>max_lineages</strong> (<em>unsigned integer</em>) &#8211; The maximum number of extant lineages.        If the simulation exceeds this limit a LibraryError is raised.</li>
<li><strong>max_time</strong> (<em>double</em>) &#8211; the maximum time we simulate back into the past. If this        parameter is 0.0 the simulation will continue until all loci have        coalesced.</li>
<li><strong>ancestry_algorithm</strong> (<em>unsigned int</em>) &#8211; currently unused</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the simulated history of the sample, (pi, tau).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">a tuple (pi, tau); pi is a list of lists of integers, and         tau is a list of lists of doubles</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first">InputError when the input is not correctly formed.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">LibraryError when the C library encounters an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="bibliography">
<h2><a class="toc-backref" href="#id31">Bibliography</a><a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="e08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[E08]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> A. Etheridge. Drift, draft and structure: some mathematical models of evolution,
<em>Banach Center Publications</em> 80, pp 121&#8211;144, 2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bev10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BEV10]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> N. H.  Barton,  A. M. Etheridge and A. Véber.
A new model for evolution in a spatial continuum, <em>Electronic Journal of
Probability</em> 15:7, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bke10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BKE10]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> N. H.  Barton,  J. Kelleher and A. M. Etheridge.
A new model for extinction and recolonisation in two dimensions: quantifying phylogeography,
<em>Evolution</em>, 64(9), pp 2701&#8211;2715, 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bev12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[BEV12]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id11">4</a>)</em> N. H.  Barton,  A. M. Etheridge and A. Véber.
Modelling Evolution in a Spatial continuum,
<em>J. Stat. Mech.</em>, to appear, 2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="k11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[K11]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> D. E. Knuth, Combinatorial Algorithms, Part 1; Volume 4A of <em>The Art of Computer
Programming</em>, 2011.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1><a class="toc-backref" href="#id32">Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Extinction/recolonisation coalescent simulator</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#samples">Samples</a></li>
<li><a class="reference internal" href="#oriented-trees-and-forests">Oriented trees and forests</a></li>
<li><a class="reference internal" href="#coalescence-times-and-mrcas">Coalescence times and MRCAs</a></li>
<li><a class="reference internal" href="#multiple-loci">Multiple loci</a></li>
<li><a class="reference internal" href="#draft">DRAFT</a></li>
<li><a class="reference internal" href="#a-full-example">A full example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-ercs"><tt class="docutils literal"><span class="pre">ercs</span></tt> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#event-classes">Event Classes</a></li>
<li><a class="reference internal" href="#ercs-simulator"><tt class="docutils literal"><span class="pre">ercs.Simulator</span></tt></a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13"><tt class="docutils literal"><span class="pre">_ercs</span></tt> &#8211; Module reference</a><ul>
<li><a class="reference internal" href="#low-level-event-classes">Low Level Event Classes</a></li>
<li><a class="reference internal" href="#simulation-interface">Simulation interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">ercs 1.0.4-dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jerome Kelleher.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>